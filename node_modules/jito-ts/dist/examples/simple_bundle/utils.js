"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.onBundleResult = exports.sendBundles = void 0;
const web3_js_1 = require("@solana/web3.js");
const bs58_1 = __importDefault(require("bs58"));
const types_1 = require("../../sdk/block-engine/types");
const utils_1 = require("../../sdk/block-engine/utils");
const MEMO_PROGRAM_ID = 'Memo1UhkJRfHyvLMcVucJwxXeuD728EqVDDwQDxFMNo';
const sendBundles = async (c, bundleTransactionLimit, keypair, conn) => {
    const _tipAccount = (await c.getTipAccounts())[0];
    console.log('tip account:', _tipAccount);
    const tipAccount = new web3_js_1.PublicKey(_tipAccount);
    const balance = await conn.getBalance(keypair.publicKey);
    console.log('current account has balance: ', balance);
    let isLeaderSlot = false;
    while (!isLeaderSlot) {
        const next_leader = await c.getNextScheduledLeader();
        const num_slots = next_leader.nextLeaderSlot - next_leader.currentSlot;
        isLeaderSlot = num_slots <= 2;
        console.log(`next jito leader slot in ${num_slots} slots`);
        await new Promise(r => setTimeout(r, 500));
    }
    const blockHash = await conn.getLatestBlockhash();
    const b = new types_1.Bundle([], bundleTransactionLimit);
    console.log(blockHash.blockhash);
    const bundles = [b];
    let maybeBundle = b.addTransactions(buildMemoTransaction(keypair, 'jito test 1', blockHash.blockhash), buildMemoTransaction(keypair, 'jito test 2', blockHash.blockhash));
    if ((0, utils_1.isError)(maybeBundle)) {
        throw maybeBundle;
    }
    maybeBundle = maybeBundle.addTipTx(keypair, 100000, tipAccount, blockHash.blockhash);
    if ((0, utils_1.isError)(maybeBundle)) {
        throw maybeBundle;
    }
    bundles.map(async (b) => {
        try {
            const resp = await c.sendBundle(b);
            console.log('resp:', resp);
        }
        catch (e) {
            console.error('error sending bundle:', e);
        }
    });
};
exports.sendBundles = sendBundles;
const onBundleResult = (c) => {
    c.onBundleResult(result => {
        console.log('received bundle result:', result);
    }, e => {
        throw e;
    });
};
exports.onBundleResult = onBundleResult;
const buildMemoTransaction = (keypair, message, recentBlockhash) => {
    const ix = new web3_js_1.TransactionInstruction({
        keys: [
            {
                pubkey: keypair.publicKey,
                isSigner: true,
                isWritable: true,
            },
        ],
        programId: new web3_js_1.PublicKey(MEMO_PROGRAM_ID),
        data: Buffer.from(message),
    });
    const instructions = [ix];
    const messageV0 = new web3_js_1.TransactionMessage({
        payerKey: keypair.publicKey,
        recentBlockhash: recentBlockhash,
        instructions,
    }).compileToV0Message();
    const tx = new web3_js_1.VersionedTransaction(messageV0);
    tx.sign([keypair]);
    console.log('txn signature is: ', bs58_1.default.encode(tx.signatures[0]));
    return tx;
};
//# sourceMappingURL=utils.js.map